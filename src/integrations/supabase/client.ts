// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://heozxmzglhrbrzpsvbrh.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imhlb3p4bXpnbGhyYnJ6cHN2YnJoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU4NzIyNTksImV4cCI6MjA2MTQ0ODI1OX0.WDib-BNHRslc7c1wTRdzufT23mCpM-TBhA_CpyxMln4";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Transaction functions
export const beginTransaction = async () => {
  try {
    return await supabase.rpc('begin_transaction');
  } catch (error) {
    console.error('Error beginning transaction:', error);
    throw error;
  }
};

export const commitTransaction = async () => {
  try {
    return await supabase.rpc('commit_transaction');
  } catch (error) {
    console.error('Error committing transaction:', error);
    throw error;
  }
};

export const rollbackTransaction = async () => {
  try {
    return await supabase.rpc('rollback_transaction');
  } catch (error) {
    console.error('Error rolling back transaction:', error);
    throw error;
  }
};

// Helper function to get current user ID
export const getCurrentUserId = async (): Promise<string | null> => {
  const { data } = await  supabase.auth.getSession().then(({ data: { session: currentSession } }) => {
      setSession(currentSession);
      if (currentSession?.user) {
        const userData = currentSession.user;
        const userMetadata = userData.user_metadata;
        
        setUser({
          id: userData.id,
          email: userData.email || '',
          name: userMetadata?.name || '',
        });
      }
      
    });
  return data.email;
};

// Helper function to check if user is admin
export const isUserAdmin = async (): Promise<boolean> => {
  const { data } = await supabase.auth.getSession();
  const user = data.session?.user;
  return user?.user_metadata?.role === 'admin';
};

// Proforma Invoice functions
export const getProformaInvoices = async () => {
  try {
    const userId = await getCurrentUserId();
    const isAdmin = await isUserAdmin();
    
    let query = supabase
      .from('proforma_invoices')
      .select('*');
    
    // If not admin, only show user's documents
    if (!isAdmin && userId) {
      query = query.eq('created_by_userid', userId);
    }
    
    const { data, error } = await query;
    
    if (error) throw error;
    return data;
  } catch (error) {
    console.error('Error fetching proforma invoices:', error);
    throw error;
  }
};

export const createProformaInvoice = async (data: any) => {
  try {
    const userId = await getCurrentUserId();
    
    if (!userId) {
      throw new Error("User not authenticated. Cannot create proforma invoice without user ID.");
    }
    
    console.log("Creating proforma invoice with user ID:", userId);
    
    // Add user ID to the data
    const invoiceData = {
      ...data,
      created_by_userid: userId
    };
    
    const { data: result, error } = await supabase
      .from('proforma_invoices')
      .insert(invoiceData)
      .select();
    
    if (error) throw error;
    return result;
  } catch (error) {
    console.error('Error creating proforma invoice:', error);
    throw error;
  }
};

// Update proforma invoice functions
export const updateProformaInvoice = async (id: string, data: any) => {
  try {
    const { data: result, error } = await supabase
      .from('proforma_invoices')
      .update(data)
      .eq('id', id)
      .select();
    
    if (error) throw error;
    return result;
  } catch (error) {
    console.error('Error updating proforma invoice:', error);
    throw error;
  }
};

export const updateProformaInvoiceItems = async (proformaId: string, items: any[]) => {
  try {
    // Start a transaction
    await beginTransaction();
    
    // Delete existing items for this proforma
    const { error: deleteError } = await supabase
      .from('proforma_invoice_items')
      .delete()
      .eq('proformainvoiceid', proformaId);
    
    if (deleteError) {
      await rollbackTransaction();
      throw deleteError;
    }
    
    // Insert new items
    const itemLinks = items.map(item => ({
      proformainvoiceid: proformaId,
      itemid: item.id
    }));
    
    const { error: insertError } = await supabase
      .from('proforma_invoice_items')
      .insert(itemLinks);
    
    if (insertError) {
      await rollbackTransaction();
      throw insertError;
    }
    
    // Commit the transaction
    await commitTransaction();
    
    return { success: true };
  } catch (error) {
    console.error('Error updating proforma invoice items:', error);
    await rollbackTransaction();
    throw error;
  }
};

export const deleteProformaInvoice = async (id: string) => {
  try {
    // Start by deleting related records in the junction table
    const { error: itemsError } = await supabase
      .from('proforma_invoice_items')
      .delete()
      .eq('proformainvoiceid', id);
    
    if (itemsError) throw itemsError;
    
    // Then delete the proforma invoice
    const { error } = await supabase
      .from('proforma_invoices')
      .delete()
      .eq('id', id);
    
    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('Error deleting proforma invoice:', error);
    throw error;
  }
};

// Final Invoice functions
export const getFinalInvoices = async () => {
  try {
    const userId = await getCurrentUserId();
    const isAdmin = await isUserAdmin();
    
    let query = supabase
      .from('final_invoices')
      .select('*');
    
    // If not admin, only show user's documents
    if (!isAdmin && userId) {
      query = query.eq('created_by_userid', userId);
    }
    
    const { data, error } = await query;
    
    if (error) throw error;
    return data;
  } catch (error) {
    console.error('Error fetching final invoices:', error);
    throw error;
  }
};

export const createFinalInvoice = async (data: any) => {
  try {
    const userId = await getCurrentUserId();
    
    if (!userId) {
      throw new Error("User not authenticated. Cannot create final invoice without user ID.");
    }
    
    // Add user ID to the data
    const invoiceData = {
      ...data,
      created_by_userid: userId
    };
    
    const { data: result, error } = await supabase
      .from('final_invoices')
      .insert(invoiceData)
      .select();
    
    if (error) throw error;
    return result;
  } catch (error) {
    console.error('Error creating final invoice:', error);
    throw error;
  }
};

// Update final invoice functions
export const updateFinalInvoice = async (id: string, data: any) => {
  try {
    const { error } = await supabase
      .from('final_invoices')
      .update(data)
      .eq('id', id);
    
    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('Error updating final invoice:', error);
    throw error;
  }
};

export const deleteFinalInvoice = async (id: string) => {
  try {
    // Start by deleting related records in the junction table
    const { error: itemsError } = await supabase
      .from('final_invoice_items')
      .delete()
      .eq('finalinvoiceid', id);
    
    if (itemsError) throw itemsError;
    
    // Then delete the final invoice
    const { error } = await supabase
      .from('final_invoices')
      .delete()
      .eq('id', id);
    
    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('Error deleting final invoice:', error);
    throw error;
  }
};

// Delivery Note functions
export const getDeliveryNotes = async () => {
  try {
    const userId = await getCurrentUserId();
    const isAdmin = await isUserAdmin();
    
    let query = supabase
      .from('delivery_notes')
      .select('*');
    
    // If not admin, only show user's documents
    if (!isAdmin && userId) {
      query = query.eq('created_by_userid', userId);
    }
    
    const { data, error } = await query;
    
    if (error) throw error;
    return data;
  } catch (error) {
    console.error('Error fetching delivery notes:', error);
    throw error;
  }
};

export const createDeliveryNote = async (data: any) => {
  try {
    const userId = await getCurrentUserId();
    
    if (!userId) {
      throw new Error("User not authenticated. Cannot create delivery note without user ID.");
    }
    
    // Add user ID to the data
    const noteData = {
      ...data,
      created_by_userid: userId
    };
    
    const { data: result, error } = await supabase
      .from('delivery_notes')
      .insert(noteData)
      .select();
    
    if (error) throw error;
    return result;
  } catch (error) {
    console.error('Error creating delivery note:', error);
    throw error;
  }
};

// Update delivery note functions
export const updateDeliveryNote = async (id: string, data: any) => {
  try {
    // Start a transaction
    await beginTransaction();
    
    try {
      // Remove items property from the data for the main update
      const { items, ...deliveryNoteData } = data;
      
      // Handle empty string and null dates properly
      if (deliveryNoteData.deliverydate === '' || deliveryNoteData.deliverydate === undefined) {
        deliveryNoteData.deliverydate = null;
      }
      
      if (deliveryNoteData.issuedate === '') {
        deliveryNoteData.issuedate = null;
      }
      
      // Ensure transportation fields are properly handled
      deliveryNoteData.drivername = deliveryNoteData.drivername || 'Unknown Driver';
      deliveryNoteData.truck_id = deliveryNoteData.truck_id || null;
      deliveryNoteData.delivery_company = deliveryNoteData.delivery_company || null;
      deliveryNoteData.driverlisence = deliveryNoteData.driverlisence || null;
      deliveryNoteData.drivertel = deliveryNoteData.drivertel || null;
      
      console.log('Updating delivery note with data:', deliveryNoteData);
      
      // Update the delivery note
      const { error: updateError } = await supabase
        .from('delivery_notes')
        .update(deliveryNoteData)
        .eq('id', id);
      
      if (updateError) throw updateError;
      
      // Handle items if provided
      if (items && Array.isArray(items) && items.length > 0) {
        // Delete existing items for this delivery note
        const { error: deleteError } = await supabase
          .from('delivery_note_items')
          .delete()
          .eq('deliverynoteid', id);
        
        if (deleteError) throw deleteError;
        
        // Create new items and link them
        for (const item of items) {
          // Create the invoice item with full details
          const { data: createdItem, error: itemError } = await supabase
            .from('invoice_items')
            .insert({
              productid: item.productId,
              quantity: item.quantity,
              unitprice: item.unitprice,
              unit: item.unit,
              taxrate: item.taxrate,
              discount: item.discount || 0,
              totalexcl: item.totalExcl,
              totaltax: item.totalTax,
              total: item.total
            })
            .select()
            .single();
          
          if (itemError) throw itemError;
          
          // Link the item to the delivery note
          const { error: linkError } = await supabase
            .from('delivery_note_items')
            .insert({
              deliverynoteid: id,
              itemid: createdItem.id
            });
          
          if (linkError) throw linkError;
        }
      }
      
      // Commit the transaction
      await commitTransaction();
      
      return { success: true };
    } catch (error) {
      await rollbackTransaction();
      throw error;
    }
  } catch (error) {
    console.error('Error updating delivery note:', error);
    throw error;
  }
};



export const deleteDeliveryNote = async (id: string) => {
  try {
    // Start by deleting related records in the junction table
    const { error: itemsError } = await supabase
      .from('delivery_note_items')
      .delete()
      .eq('deliverynoteid', id);
    
    if (itemsError) throw itemsError;
    
    // Then delete the delivery note
    const { error } = await supabase
      .from('delivery_notes')
      .delete()
      .eq('id', id);
    
    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error('Error deleting delivery note:', error);
    throw error;
  }
};

// Invoice payment functions
export const addInvoicePayment = async (invoiceId: string, paymentData: any) => {
  try {
    await beginTransaction();

    // Add the payment record
    const { data: payment, error: paymentError } = await supabase
      .from('invoice_payments')
      .insert({
        invoiceid: invoiceId,
        amount: paymentData.amount,
        payment_date: paymentData.payment_date,
        paymentmethod: paymentData.paymentMethod,
        reference: paymentData.reference,
        notes: paymentData.notes || null
      })
      .select()
      .single();
    
    if (paymentError) {
      await rollbackTransaction();
      throw paymentError;
    }
    
    console.log('Payment added:', payment);
    
    // Get the invoice to calculate the new amount_paid and client_debt
    const { data: invoice, error: invoiceError } = await supabase
      .from('final_invoices')
      .select('total, amount_paid, client_debt, status')
      .eq('id', invoiceId)
      .single();
    
    if (invoiceError) {
      await rollbackTransaction();
      throw invoiceError;
    }
    
    console.log('Current invoice data:', invoice);
    
    // Calculate new values
    const currentAmountPaid = invoice.amount_paid || 0;
    const newAmountPaid = currentAmountPaid + paymentData.amount;
    const newClientDebt = invoice.total - newAmountPaid;
    
    console.log('Calculated new values:', {
      currentAmountPaid,
      newAmountPaid,
      newClientDebt
    });
    
    // Determine the new status based on the payment
    // Make sure we use only valid status values from the database constraint
    let newStatus = invoice.status;
    
    if (newAmountPaid >= invoice.total) {
      newStatus = 'payé';
    } else if (newAmountPaid > 0 && newAmountPaid < invoice.total) {
      newStatus = 'partially_paid';
    } else if (newAmountPaid <= 0) {
      newStatus = 'NonPayé';
    }
    
    // Update the invoice with the new amounts and status
    const { error: updateError } = await supabase
      .from('final_invoices')
      .update({
        amount_paid: newAmountPaid,
        client_debt: newClientDebt > 0 ? newClientDebt : 0,
        status: newStatus
      })
      .eq('id', invoiceId);
    
    if (updateError) {
      console.error('Error updating invoice:', updateError);
      await rollbackTransaction();
      throw updateError;
    }
    
    await commitTransaction();
    return { success: true, payment };
  } catch (error) {
    console.error('Error adding invoice payment:', error);
    await rollbackTransaction();
    throw error;
  }
};

export const getInvoicePayments = async (invoiceId: string) => {
  try {
    const { data, error } = await supabase
      .from('invoice_payments')
      .select('*')
      .eq('invoiceid', invoiceId)
      .order('payment_date', { ascending: false });
    
    if (error) throw error;
    
    return data.map(payment => ({
      id: payment.id,
      invoiceId: payment.invoiceid,
      amount: payment.amount,
      payment_date: payment.payment_date,
      paymentMethod: payment.paymentmethod,
      reference: payment.reference,
      notes: payment.notes,
      createdAt: payment.createdat
    }));
  } catch (error) {
    console.error('Error fetching invoice payments:', error);
    throw error;
  }
};

export const deleteInvoicePayment = async (paymentId: string, invoiceId: string) => {
  try {
    await beginTransaction();
    
    // Get the payment amount
    const { data: payment, error: paymentQueryError } = await supabase
      .from('invoice_payments')
      .select('amount')
      .eq('id', paymentId)
      .single();
    
    if (paymentQueryError) {
      await rollbackTransaction();
      throw paymentQueryError;
    }
    
    // Delete the payment
    const { error: deleteError } = await supabase
      .from('invoice_payments')
      .delete()
      .eq('id', paymentId);
    
    if (deleteError) {
      await rollbackTransaction();
      throw deleteError;
    }
    
    // Get the invoice to recalculate values
    const { data: invoice, error: invoiceError } = await supabase
      .from('final_invoices')
      .select('total, amount_paid')
      .eq('id', invoiceId)
      .single();
    
    if (invoiceError) {
      await rollbackTransaction();
      throw invoiceError;
    }
    
    // Calculate new values
    const newAmountPaid = (invoice.amount_paid || 0) - payment.amount;
    const newClientDebt = invoice.total - newAmountPaid;
    
    // Determine the new status
    let newStatus = 'NonPayé';
    if (newAmountPaid >= invoice.total) {
      newStatus = 'payé';
    } else if (newAmountPaid > 0) {
      newStatus = 'partially_paid';
    }
    
    // Update the invoice
    const { error: updateError } = await supabase
      .from('final_invoices')
      .update({
        amount_paid: newAmountPaid > 0 ? newAmountPaid : 0,
        client_debt: newClientDebt > 0 ? newClientDebt : 0,
        status: newStatus
      })
      .eq('id', invoiceId);
    
    if (updateError) {
      await rollbackTransaction();
      throw updateError;
    }
    
    await commitTransaction();
    return { success: true };
  } catch (error) {
    console.error('Error deleting invoice payment:', error);
    await rollbackTransaction();
    throw error;
  }
};

// Function to handle disconnecting a proforma from a final invoice
export const undoProformaConversion = async (proformaId: string, finalInvoiceId: string) => {
  try {
    // Update the proforma invoice to remove the finalInvoiceId reference
    const { error: proformaError } = await supabase
      .from('proforma_invoices')
      .update({ finalinvoiceid: null })
      .eq('id', proformaId);
    
    if (proformaError) throw proformaError;
    
    // Delete the final invoice
    return await deleteFinalInvoice(finalInvoiceId);
  } catch (error) {
    console.error('Error undoing proforma conversion:', error);
    throw error;
  }
};

export const Br = {
  updateProformaInvoice,
};
